// this is the screenstory object
'use strict';

var fs              = require('fs');
var fse             = require('fs-extra');
var _               = require('lodash');
var VError          = require('verror');
var path            = require('path');
var sanitize        = require('sanitize-filename');
var morph           = require('morph');
var debug           = require('debug')('screenstory:screenstory');



function Screenstory(screenshotsDir) {
    this.data = [];
    this.screenshotsDir = screenshotsDir;
}

Screenstory.prototype.browserId = Screenstory.prototype.screenshotRoot = function (capabilities) {
    var id = [];
    ['browserName', 'version', 'device', 'deviceName'].forEach(function (prop) {
        if (capabilities[prop]) {
            id.push(dasherize(capabilities[prop]));
        }
    });

    return id.join('_');
};
Screenstory.prototype.storyRoot = function storyRoot(capabilities, story) {
    var screenshotRoot = this.screenshotRoot(capabilities);
    var storyId = dasherize(story) ||Â '';
    var destPath = path.join(screenshotRoot, storyId);

    return this.browserPath(destPath);
};

// Enrich image with webdriver screenshot context from options.
// As an output you can expect:
//
// * browserId: unique id for given capabilities
// * fileOriginal: the path to original screenshot file
// * fileNew: the path to new screenshot file
// * fileDiff: the path to new screenshot file
// * fileDocument: the path of document screenshot
// * isNew: is it a new screenshot for those capabilities
//
// Possible options are:
//
// * capabilities:  the current client capabilities ("client.desiredCapabilities")
// * title:         (optional) the image human readable title
// * story:         (optional) the story human readable title
// * id:            (optional) the image unique id. Maybe best to keep it generated by screenstory.
// * storyId:       (optional) the story unique id. Maybe best to keep it generated by screenstory.
Screenstory.prototype.loadWebdrivercss = function loadWebdrivercss(image) {
    if (!image.capabilities) {
        throw new VError('Option "capabilities" is required.\nHINT: You can provide "client.desiredCapabilities".');
    }
    var suffix = '';

    // Generate image location relative to screenshot root from options
    image.browserId = this.browserId(image.capabilities);
    image.id = image.id || dasherize(image.title) || this.data.length;
    image.storyId = image.storyId || dasherize(image.story);

    if (image.diff && image.width && image.width.length) {
        if (Array.isArray(image.width)) {
            suffix = image.width[0];
        } else {
            suffix = image.width;
        }
        suffix = '.' + suffix;
    }

    // And use it to generate image filepath
    image.fileNew = this.generatePath(image.capabilities, image.storyId, image.id + suffix +'.new.png');
    image.fileOriginal = this.generatePath(image.capabilities, image.storyId, image.id + suffix + '.current.png');
    image.fileDiff = this.generatePath(image.capabilities, image.storyId, path.join('diff', image.id) + suffix + '.diff.png');
    image.fileDocument = this.generatePath(image.capabilities, image.storyId, image.id + suffix + '.png');


    if (!fs.existsSync(image.fileOriginal)) {
        image.isNew = true;
    } else {
        image.urlOriginal = 'data:image/png;base64,' + fs.readFileSync(image.fileOriginal).toString('base64');
    }

    return image;
};

// Enrich image with webdriver screenshot context from options.
//
// Note: You MUST call `screenstory.loadWebdrivercss` first.
//
// As an output you can expect:
//
// * browserId:     unique id for given capabilities
// * fileDocument:  the path to original screenshot file
// * fileOriginal:  the path to original screenshot file
// * fileNew:       the path to new screenshot file
// * fileDiff:      the path to new screenshot file
// * urlDocument:   the url to original screenshot file
// * urlOriginal:   the url to original screenshot file
// * urlNew:        the url to new screenshot file
// * urlDiff:       the url to new screenshot file
// * isNew:         is it a new screenshot for those capabilities
// * isModified:    is it a new screenshot for those capabilities
// * diff:          webdrivercss response
// * capabilities:  the current client capabilities ("client.desiredCapabilities")
// * title:         the image human readable title
// * story:         the story human readable title
// * id:            the image unique id. Maybe best to keep it generated by screenstory.
// * storyId:       the story unique id. Maybe best to keep it generated by screenstory.
Screenstory.prototype.saveWebdrivercssResponse = function (image, response, cb) {
    var self = this;

    if (!image.id) {
        throw new VError('Option "id" is required.\nHINT: You should have called "screenstory.loadWebdrivercss(image)" before.');
    }
    if (!image.capabilities) {
        throw new VError('Option "capabilities" is required.\nHINT: You can provide "client.desiredCapabilities".');
    }

    // Read image id
    var id = image.id;

    // Is there a new image ?
    if (fs.existsSync(image.fileNew)) {
        image.fullpath = image.fileNew;
        // There is a new image, this becomes the default image
        image.urlNew = 'data:image/png;base64,' + fs.readFileSync(image.fileNew).toString('base64');
        image.url = image.urlNew;
        image.isModified = true;
    } else {
        image.fullpath = image.fileOriginal;
        // No new image ? Reload original.
        image.isModified = false;
        if (fs.existsSync(image.fileOriginal)) {
            image.url = 'data:image/png;base64,' + fs.readFileSync(image.fileOriginal).toString('base64');
        } else {
            image.url = null;
        }
        image.fileNew = null;
        image.urlNew = null;
    }

    if (fs.existsSync(image.fileDiff)) {
        image.fullpath = image.fileDiff;
        image.urlDiff = 'data:image/png;base64,' + fs.readFileSync(image.fileDiff).toString('base64');
        image.url = image.urlDiff;
    } else {
        image.urlDiff = null;
        image.fileDiff = null;
    }

    if (fs.existsSync(image.fileDocument)) {
        image.fullpath = image.fileDocument;
        image.urlDocument = 'data:image/png;base64,' + fs.readFileSync(image.fileDocument).toString('base64');
        if (!image.url) {
            image.url = image.urlDocument;
        }
    }

    image.diff = response;

    self.data.push(image);

    cb();
};


Screenstory.prototype.save = function save(image, options, cb) {
    var self = this;

    // extract browser id from capabilities
    if (!options.capabilities) {
        return cb(new VError('Option "capabilities" is required.\nHINT: You can provide "client.desiredCapabilities".'));
    }
    var id = dasherize(options.id || options.title || this.data.length);

    options.browserId = this.browserId(options.capabilities);
    options.storyId = options.storyId || dasherize(options.story);
    options.title = options.title || id;
    options.imageUrl = 'data:image/png;base64,' + image.toString('base64');

    var dest = this.generatePath(options.capabilities, options.storyId, id + '.png');
    // we are about to create parent directory
    var screenshotsDir = path.dirname(dest);

    fse.mkdirs(screenshotsDir, function writeScreenshotFile(err) {
        if (err) { return cb(err); }

        fs.writeFile(dest, image.value, 'base64', function pushDataToScreenstory(err) {
            if (err) { return cb(err); }

            options.fullpath = dest;
            self.data.push(options);

            cb();
        });
    });

    return dest;
};

Screenstory.prototype.generatePath = function generatePath(capabilities, storyId, id) {
    var screenshotRoot = this.storyRoot(capabilities, storyId);
    var dest = path.join(screenshotRoot, id);
    return dest;
};

Screenstory.prototype.browserPath = function browserPath(browserName) {
    var dest = path.join(this.screenshotsDir, browserName);
    return dest;
};


Screenstory.prototype.generateReport = function (options, cb) {
    var data = groupByBrowser(this.data);
    var browserId;
    var reports = [];
    if (!cb) {
        cb = options;
        options = {};
    }

    try {
        for (browserId in data) {
            if (data.hasOwnProperty(browserId)) {
                var reportPath = this.browserPath(browserId) + '.html';
                if (data.hasOwnProperty(browserId)) {
                    generateBrowserReport(reportPath, browserId, {
                        screenstories: data[browserId],
                        options: options
                    });
                    reports.push(reportPath);
                }
            }
        }
        cb(null, reports);
    } catch(e) {
        debug(e);
        cb(new VError(e, 'Unable to generate report'));
    }
};

module.exports = function (screenshotsDir) {
    return new Screenstory(screenshotsDir);
};

function dasherize(str){
    if (!str) { return str; }
    return morph.toDashed(sanitize(str.toString().trim()));
}

function groupByBrowser(data) {
    return _.groupBy(data, 'browserId');
}

function groupByStory(data) {
    var stories = {};
    _.each(data, function (screenshot) {
        stories[screenshot.storyId] = stories[screenshot.storyId] || {
            title: screenshot.story || screenshot.storyId,
            screenshots: []
        };
        stories[screenshot.storyId].screenshots.push(screenshot);
    });

    return stories;
}

function prepareData(data) {

    data = groupByStory(data);

    // transform to array
    var ret = [];
    _.each(data, function (story) {
        ret.push(story);
    });

    return ret;
}

function generateBrowserReport(destFile, browserName, data) {
    var reportFile = path.join(__dirname, '..', 'reportTpl.html');
    var destPath = path.dirname(destFile);

    if (!fs.existsSync(reportFile)) {
        throw new VError('Unable to load report template %s', reportFile);
    }

    var tpl = fs.readFileSync(reportFile);

    tpl = _.template(tpl);

    var html = tpl({
        browserName: browserName,
        data: prepareData(data.screenstories),
        options: data.options,
        imageUrl: function (item) {
            return relativePath(
                selectImageToDisplay(item, data.options),
                destPath);
        }
    });

    fs.writeFileSync(destFile, html);
}

function selectImageToDisplay(item, options) {
    if (!options.screenshotDiff) {
        return item.fileDocument;
    } else if (item.fileDiff) {
        return item.fileDiff;
    } else if (item.fileNew) {
        return item.fileNew;
    } else {
        return item.fileOriginal;
    }
}
function relativePath(fullpath, destPath) {
    return path.relative(destPath, fullpath);
}
