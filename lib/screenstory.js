// this is the screenstory object
'use strict';

var fs              = require('fs');
var fse             = require('fs-extra');
var _               = require('lodash');
var VError          = require('verror');
var path            = require('path');
var sanitize        = require('sanitize-filename');
var morph           = require('morph');
var debug           = require('debug')('screenstory:screenstory');
var async           = require('async');



function Screenstory(screenshotsDir) {
    this.data = [];
    this.screenshotsDir = screenshotsDir;
}

Screenstory.prototype.browserId = Screenstory.prototype.screenshotRoot = function (capabilities) {
    var id = [];
    ['browserName', 'version', 'device', 'deviceName'].forEach(function (prop) {
        if (capabilities[prop]) {
            id.push(dasherize(capabilities[prop]));
        }
    });

    return id.join('_');
};
Screenstory.prototype.storyRoot = function storyRoot(capabilities, story) {
    var screenshotRoot = this.screenshotRoot(capabilities);
    var storyId = dasherize(story) ||Â '';
    var destPath = path.join(screenshotRoot, storyId);

    return this.browserPath(destPath);
};

// Enrich image with webdriver screenshot context from options.
// As an output you can expect:
//
// * browserId: unique id for given capabilities
// * fileOriginal: the path to original screenshot file
// * isNew: is it a new screenshot for those capabilities
//
// Possible options are:
//
// * capabilities:  the current client capabilities ("client.desiredCapabilities")
// * title:         (optional) the image human readable title
// * story:         (optional) the story human readable title
// * id:            (optional) the image unique id. Maybe best to keep it generated by screenstory.
// * storyId:       (optional) the story unique id. Maybe best to keep it generated by screenstory.
Screenstory.prototype.loadWebdrivercss = function loadWebdrivercss(image) {
    if (!image.capabilities) {
        throw new VError('Option "capabilities" is required.\nHINT: You can provide "client.desiredCapabilities".');
    }
    var suffix = '';

    // Generate image location relative to screenshot root from options
    image.browserId = this.browserId(image.capabilities);
    image.id = image.id || dasherize(image.title) || this.data.length;
    image.storyId = image.storyId || dasherize(image.story);

    if (image.diff && image.width && image.width.length) {
        if (Array.isArray(image.width)) {
            suffix = image.width[0];
        } else {
            suffix = image.width + 'px';
        }
        suffix = '.' + suffix;
    }

    // And use it to generate image filepath
    image.fileOriginal = this.generatePath(image.capabilities, image.storyId, image.id + suffix + '.baseline.png');

    if (!fs.existsSync(image.fileOriginal)) {
        image.isNew = true;
    }

    return image;
};

// Enrich image with webdriver screenshot context from options.
//
// Note: You MUST call `screenstory.loadWebdrivercss` first.
Screenstory.prototype.saveWebdrivercssResponse = function (image, response, cb) {
    var self = this;

    if (Array.isArray(response)) {
        return async.each(
            response,
            function (item, next) {
                self.saveWebdrivercssResponse(image, item, next);
            },
            cb);
    }

    if (!image.id) {
        throw new VError('Option "id" is required.\nHINT: You should have called "screenstory.loadWebdrivercss(image)" before.');
    }
    if (!image.capabilities) {
        throw new VError('Option "capabilities" is required.\nHINT: You can provide "client.desiredCapabilities".');
    }

    response = response || {};

    var testObject = {
        // unique id for given capabilities
        browserId: image.browserId,
        // the image unique id. Maybe best to keep it generated by screenstory.
        id: image.id,
        // the story unique id. Maybe best to keep it generated by screenstory.
        storyId: image.storyId,
        // the image human readable title
        title: image.title,
        // the story human readable title
        story: image.story,
        // the current client capabilities ("client.desiredCapabilities")
        capabilities: image.capabilities,
        // the path to original screenshot file
        baselinePath: response.baselinePath,
        // the path to current screenshot file if any change
        regressionPath: response.regressionPath,
        // path to diff image
        diffPath: response.diffPath,
        // test result message
        message: response.message,
        // diff percentage
        misMatchPercentage:response.misMatchPercentage,
        // is it a new screenshot for those capabilities
        isNewImage: image.isNew,
        isExactSameImage: response.isExactSameImage,
        isSameDimensions: response.isSameDimensions,
        isWithinMisMatchTolerance: response.isWithinMisMatchTolerance
    };

    self.data.push(testObject);

    cb();
};


Screenstory.prototype.save = function save(image, options, cb) {
    var self = this;

    // extract browser id from capabilities
    if (!options.capabilities) {
        return cb(new VError('Option "capabilities" is required.\nHINT: You can provide "client.desiredCapabilities".'));
    }
    var id = dasherize(options.id || options.title || this.data.length);

    options.browserId = this.browserId(options.capabilities);
    options.storyId = options.storyId || dasherize(options.story);
    options.title = options.title || id;
    options.imageUrl = 'data:image/png;base64,' + image.toString('base64');

    var dest = this.generatePath(options.capabilities, options.storyId, id + '.png');
    // we are about to create parent directory
    var screenshotsDir = path.dirname(dest);

    fse.mkdirs(screenshotsDir, function writeScreenshotFile(err) {
        if (err) { return cb(err); }

        fs.writeFile(dest, image.value, 'base64', function pushDataToScreenstory(err) {
            if (err) { return cb(err); }

            options.fullpath = dest;
            self.data.push(options);

            cb();
        });
    });

    return dest;
};

Screenstory.prototype.generatePath = function generatePath(capabilities, storyId, id) {
    var screenshotRoot = this.storyRoot(capabilities, storyId);
    var dest = path.join(screenshotRoot, id);
    return dest;
};

Screenstory.prototype.browserPath = function browserPath(browserName) {
    var dest = path.join(this.screenshotsDir, browserName);
    return dest;
};


Screenstory.prototype.generateReport = function (options, cb) {
    var data = groupByBrowser(this.data);
    var browserId;
    var reports = [];
    if (!cb) {
        cb = options;
        options = {};
    }

    try {
        for (browserId in data) {
            debug('Generate report for %s', browserId);
            if (data.hasOwnProperty(browserId)) {
                var reportPath = this.browserPath(browserId) + '.html';
                if (data.hasOwnProperty(browserId)) {
                    generateBrowserReport(reportPath, browserId, {
                        screenstories: data[browserId],
                        options: options
                    });
                    reports.push(reportPath);
                }
            }
        }
        cb(null, reports);
    } catch(e) {
        debug(e);
        cb(new VError(e, 'Unable to generate report'));
    }
};

module.exports = function (screenshotsDir) {
    return new Screenstory(screenshotsDir);
};

function dasherize(str){
    if (!str) { return str; }
    return morph.toDashed(sanitize(str.toString().trim()));
}

function groupByBrowser(data) {
    return _.groupBy(data, 'browserId');
}

function groupByStory(data) {
    var stories = {};
    _.each(data, function (screenshot) {
        stories[screenshot.storyId] = stories[screenshot.storyId] || {
            title: screenshot.story || screenshot.storyId,
            screenshots: []
        };
        stories[screenshot.storyId].screenshots.push(screenshot);
    });

    return stories;
}

function prepareData(data) {

    data = groupByStory(data);

    // transform to array
    var ret = [];
    _.each(data, function (story) {
        ret.push(story);
    });

    return ret;
}

function generateBrowserReport(destFile, browserName, data) {
    var reportFile = path.join(__dirname, '..', 'reportTpl.html');
    var destPath = path.dirname(destFile);

    if (!fs.existsSync(reportFile)) {
        throw new VError('Unable to load report template %s', reportFile);
    }

    var tpl = fs.readFileSync(reportFile);

    tpl = _.template(tpl);

    var html = tpl({
        browserName: browserName,
        data: prepareData(data.screenstories),
        options: data.options,
        imageUrl: function (item) {
            return relativePath(
                selectImageToDisplay(item, data.options),
                destPath);
        }
    });

    fs.writeFileSync(destFile, html);
}

function selectImageToDisplay(item, options) {
    if (item.isWithinMisMatchTolerance === false) {
        return item.diffPath;
    }
    else if (item.isNewImage) {
        return item.baselinePath;
    }
    return item.regressionPath;
}
function relativePath(fullpath, destPath) {
    if (!fullpath) {
        return '';
    }
    return path.relative(destPath, fullpath);
}
